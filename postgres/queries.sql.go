// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package postgres

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const deleteFailed = `-- name: DeleteFailed :exec
DELETE FROM "poutbox".failed
WHERE id = $1::bigint
`

func (q *Queries) DeleteFailed(ctx context.Context, db DBTX, id int64) error {
	_, err := db.ExecContext(ctx, deleteFailed, id)
	return err
}

const deleteFailedBatch = `-- name: DeleteFailedBatch :exec
DELETE FROM "poutbox".failed
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteFailedBatch(ctx context.Context, db DBTX, ids []int64) error {
	_, err := db.ExecContext(ctx, deleteFailedBatch, pq.Array(ids))
	return err
}

const deleteImmediate = `-- name: DeleteImmediate :exec
DELETE FROM "poutbox".immediate
WHERE id = $1::bigint
`

func (q *Queries) DeleteImmediate(ctx context.Context, db DBTX, id int64) error {
	_, err := db.ExecContext(ctx, deleteImmediate, id)
	return err
}

const deletePartitionMeta = `-- name: DeletePartitionMeta :exec
DELETE FROM "poutbox".partition_meta
WHERE partition_name = $1
`

func (q *Queries) DeletePartitionMeta(ctx context.Context, db DBTX, partitionName string) error {
	_, err := db.ExecContext(ctx, deletePartitionMeta, partitionName)
	return err
}

const deleteScheduledBatch = `-- name: DeleteScheduledBatch :exec
DELETE FROM "poutbox".scheduled
WHERE id = ANY($1::bigint[])
`

func (q *Queries) DeleteScheduledBatch(ctx context.Context, db DBTX, ids []int64) error {
	_, err := db.ExecContext(ctx, deleteScheduledBatch, pq.Array(ids))
	return err
}

const enqueueImmediate = `-- name: EnqueueImmediate :one
INSERT INTO "poutbox".immediate (payload)
VALUES ($1)
RETURNING id
`

func (q *Queries) EnqueueImmediate(ctx context.Context, db DBTX, payload []byte) (int64, error) {
	row := db.QueryRowContext(ctx, enqueueImmediate, payload)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const enqueueScheduled = `-- name: EnqueueScheduled :one
INSERT INTO "poutbox".scheduled (payload, scheduled_at)
VALUES ($1, $2)
RETURNING id
`

type EnqueueScheduledParams struct {
	Payload     []byte
	ScheduledAt time.Time
}

func (q *Queries) EnqueueScheduled(ctx context.Context, db DBTX, arg EnqueueScheduledParams) (int64, error) {
	row := db.QueryRowContext(ctx, enqueueScheduled, arg.Payload, arg.ScheduledAt)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getCursor = `-- name: GetCursor :one
SELECT id, last_processed_id, last_processed_at, last_processed_transaction_id, updated_at
FROM "poutbox".cursor
WHERE id = 1
`

func (q *Queries) GetCursor(ctx context.Context, db DBTX) (PoutboxCursor, error) {
	row := db.QueryRowContext(ctx, getCursor)
	var i PoutboxCursor
	err := row.Scan(
		&i.ID,
		&i.LastProcessedID,
		&i.LastProcessedAt,
		&i.LastProcessedTransactionID,
		&i.UpdatedAt,
	)
	return i, err
}

const getFailedJobsReady = `-- name: GetFailedJobsReady :many
SELECT id, payload, error_message, retry_count, failed_at, next_retry_at
FROM "poutbox".failed
WHERE next_retry_at <= NOW() AT TIME ZONE 'UTC'
ORDER BY next_retry_at, id
LIMIT $1
`

func (q *Queries) GetFailedJobsReady(ctx context.Context, db DBTX, batchSize int32) ([]PoutboxFailed, error) {
	rows, err := db.QueryContext(ctx, getFailedJobsReady, batchSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PoutboxFailed
	for rows.Next() {
		var i PoutboxFailed
		if err := rows.Scan(
			&i.ID,
			&i.Payload,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.FailedAt,
			&i.NextRetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getImmediateJobs = `-- name: GetImmediateJobs :many
SELECT id, payload, created_at, transaction_id
FROM "poutbox".immediate
WHERE
  created_at >= $1::timestamptz
  AND (
    (transaction_id = $2::bigint AND id > $3::bigint)
    OR (transaction_id > $2::bigint)
  )
  AND transaction_id < pg_snapshot_xmin(pg_current_snapshot())::text::bigint
ORDER BY transaction_id ASC, id ASC
LIMIT $4
`

type GetImmediateJobsParams struct {
	LastProcessedAt            time.Time
	LastProcessedTransactionID int64
	LastProcessedID            int64
	BatchSize                  int32
}

func (q *Queries) GetImmediateJobs(ctx context.Context, db DBTX, arg GetImmediateJobsParams) ([]PoutboxImmediate, error) {
	rows, err := db.QueryContext(ctx, getImmediateJobs,
		arg.LastProcessedAt,
		arg.LastProcessedTransactionID,
		arg.LastProcessedID,
		arg.BatchSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PoutboxImmediate
	for rows.Next() {
		var i PoutboxImmediate
		if err := rows.Scan(
			&i.ID,
			&i.Payload,
			&i.CreatedAt,
			&i.TransactionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduledJobsReady = `-- name: GetScheduledJobsReady :many
SELECT id, payload, scheduled_at
FROM "poutbox".scheduled
WHERE scheduled_at <= NOW() AT TIME ZONE 'UTC'
ORDER BY scheduled_at, id
LIMIT $1
`

type GetScheduledJobsReadyRow struct {
	ID          int64
	Payload     []byte
	ScheduledAt time.Time
}

func (q *Queries) GetScheduledJobsReady(ctx context.Context, db DBTX, batchSize int32) ([]GetScheduledJobsReadyRow, error) {
	rows, err := db.QueryContext(ctx, getScheduledJobsReady, batchSize)
	if err != nil {
		return nil, err
	}
	defer func() {
		_ = rows.Close()
	}()

	var items []GetScheduledJobsReadyRow
	for rows.Next() {
		var i GetScheduledJobsReadyRow
		if err := rows.Scan(&i.ID, &i.Payload, &i.ScheduledAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDeadLetter = `-- name: InsertDeadLetter :exec
INSERT INTO "poutbox".dead_letter (id, payload, error_message, retry_count, failed_at)
VALUES ($1::bigint, $2, $3, $4, NOW() AT TIME ZONE 'UTC')
`

type InsertDeadLetterParams struct {
	ID           int64
	Payload      []byte
	ErrorMessage sql.NullString
	RetryCount   int32
}

func (q *Queries) InsertDeadLetter(ctx context.Context, db DBTX, arg InsertDeadLetterParams) error {
	_, err := db.ExecContext(ctx, insertDeadLetter,
		arg.ID,
		arg.Payload,
		arg.ErrorMessage,
		arg.RetryCount,
	)
	return err
}

const insertDeadLetterBatch = `-- name: InsertDeadLetterBatch :exec
INSERT INTO "poutbox".dead_letter (id, payload, error_message, retry_count, failed_at)
SELECT t.id, t.payload, t.error_message, t.retry_count, NOW() AT TIME ZONE 'UTC'
FROM (
  SELECT
    UNNEST($1::bigint[]) as id,
    UNNEST($2::bytea[]) as payload,
    UNNEST($3::text[]) as error_message,
    UNNEST($4::integer[]) as retry_count
) t
`

type InsertDeadLetterBatchParams struct {
	Ids           []int64
	Payloads      [][]byte
	ErrorMessages []string
	RetryCounts   []int32
}

func (q *Queries) InsertDeadLetterBatch(ctx context.Context, db DBTX, arg InsertDeadLetterBatchParams) error {
	_, err := db.ExecContext(ctx, insertDeadLetterBatch,
		pq.Array(arg.Ids),
		pq.Array(arg.Payloads),
		pq.Array(arg.ErrorMessages),
		pq.Array(arg.RetryCounts),
	)
	return err
}

const insertFailed = `-- name: InsertFailed :exec
INSERT INTO "poutbox".failed (id, payload, error_message, retry_count, failed_at, next_retry_at)
VALUES ($1::bigint, $2, $3, $4, NOW() AT TIME ZONE 'UTC', NOW() AT TIME ZONE 'UTC')
ON CONFLICT (id) DO UPDATE SET
    error_message = $3,
    retry_count = $4,
    next_retry_at = NOW() AT TIME ZONE 'UTC'
`

type InsertFailedParams struct {
	ID           int64
	Payload      []byte
	ErrorMessage sql.NullString
	RetryCount   int32
}

func (q *Queries) InsertFailed(ctx context.Context, db DBTX, arg InsertFailedParams) error {
	_, err := db.ExecContext(ctx, insertFailed,
		arg.ID,
		arg.Payload,
		arg.ErrorMessage,
		arg.RetryCount,
	)
	return err
}

const insertFailedBatch = `-- name: InsertFailedBatch :exec
INSERT INTO "poutbox".failed (id, payload, error_message, retry_count, failed_at, next_retry_at)
SELECT t.id, t.payload, t.error_message, t.retry_count, NOW() AT TIME ZONE 'UTC', NOW() AT TIME ZONE 'UTC'
FROM (
  SELECT
    UNNEST($1::bigint[]) as id,
    UNNEST($2::bytea[]) as payload,
    UNNEST($3::text[]) as error_message,
    UNNEST($4::integer[]) as retry_count
) t
ON CONFLICT (id) DO UPDATE SET
    error_message = EXCLUDED.error_message,
    retry_count = EXCLUDED.retry_count,
    next_retry_at = NOW() AT TIME ZONE 'UTC'
`

type InsertFailedBatchParams struct {
	Ids           []int64
	Payloads      [][]byte
	ErrorMessages []string
	RetryCounts   []int32
}

func (q *Queries) InsertFailedBatch(ctx context.Context, db DBTX, arg InsertFailedBatchParams) error {
	_, err := db.ExecContext(ctx, insertFailedBatch,
		pq.Array(arg.Ids),
		pq.Array(arg.Payloads),
		pq.Array(arg.ErrorMessages),
		pq.Array(arg.RetryCounts),
	)
	return err
}

const insertPartitionMeta = `-- name: InsertPartitionMeta :exec
INSERT INTO "poutbox".partition_meta (partition_name, range_start, range_end)
VALUES ($1, $2, $3)
ON CONFLICT (partition_name) DO NOTHING
`

type InsertPartitionMetaParams struct {
	PartitionName string
	RangeStart    time.Time
	RangeEnd      time.Time
}

func (q *Queries) InsertPartitionMeta(ctx context.Context, db DBTX, arg InsertPartitionMetaParams) error {
	_, err := db.ExecContext(ctx, insertPartitionMeta, arg.PartitionName, arg.RangeStart, arg.RangeEnd)
	return err
}

const listPartitions = `-- name: ListPartitions :many
SELECT partition_name, range_start, range_end
FROM "poutbox".partition_meta
ORDER BY range_start ASC
`

type ListPartitionsRow struct {
	PartitionName string
	RangeStart    time.Time
	RangeEnd      time.Time
}

func (q *Queries) ListPartitions(ctx context.Context, db DBTX) ([]ListPartitionsRow, error) {
	rows, err := db.QueryContext(ctx, listPartitions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPartitionsRow
	for rows.Next() {
		var i ListPartitionsRow
		if err := rows.Scan(&i.PartitionName, &i.RangeStart, &i.RangeEnd); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCursor = `-- name: UpdateCursor :exec
UPDATE "poutbox".cursor
SET last_processed_id = $1::bigint, last_processed_at = $2::timestamptz, last_processed_transaction_id = $3::bigint, updated_at = NOW() AT TIME ZONE 'UTC'
WHERE id = 1
`

type UpdateCursorParams struct {
	LastProcessedID            int64
	LastProcessedAt            time.Time
	LastProcessedTransactionID int64
}

func (q *Queries) UpdateCursor(ctx context.Context, db DBTX, arg UpdateCursorParams) error {
	_, err := db.ExecContext(ctx, updateCursor, arg.LastProcessedID, arg.LastProcessedAt, arg.LastProcessedTransactionID)
	return err
}

const updateFailed = `-- name: UpdateFailed :exec
UPDATE "poutbox".failed
SET error_message = $1, retry_count = $2, next_retry_at = NOW() AT TIME ZONE 'UTC'
WHERE id = $3::bigint
`

type UpdateFailedParams struct {
	ErrorMessage sql.NullString
	RetryCount   int32
	ID           int64
}

func (q *Queries) UpdateFailed(ctx context.Context, db DBTX, arg UpdateFailedParams) error {
	_, err := db.ExecContext(ctx, updateFailed, arg.ErrorMessage, arg.RetryCount, arg.ID)
	return err
}

const updateScheduledCursor = `-- name: UpdateScheduledCursor :exec
UPDATE "poutbox".cursor
SET last_processed_transaction_id = $1::xid8, last_processed_scheduled_id = $2::bigint, last_processed_scheduled_at = $3::timestamptz, updated_at = NOW() AT TIME ZONE 'UTC'
WHERE id = 1
`

type UpdateScheduledCursorParams struct {
	LastProcessedTransactionID int64
	LastProcessedScheduledID   int64
	LastProcessedScheduledAt   time.Time
}

func (q *Queries) UpdateScheduledCursor(ctx context.Context, db DBTX, arg UpdateScheduledCursorParams) error {
	_, err := db.ExecContext(ctx, updateScheduledCursor, arg.LastProcessedTransactionID, arg.LastProcessedScheduledID, arg.LastProcessedScheduledAt)
	return err
}
